<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Sprint Dynasty MVP</title>
<style>
  body { margin:0; background:#1b1f2a; font-family: system-ui, -apple-system, "Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif; }
  .wrap { display:flex; justify-content:center; padding:18px; }
  canvas { background:#0f2a4d; border-radius:16px; box-shadow: 0 10px 30px rgba(0,0,0,.45); }
  .hud {
    max-width:1000px; margin:0 auto; color:#eaf2ff; padding:0 18px 18px;
    display:flex; gap:10px; flex-wrap:wrap; align-items:center;
  }
  .card {
    background:rgba(0,0,0,.35); border:1px solid rgba(255,255,255,.10); border-radius:14px;
    padding:10px 12px; display:flex; gap:10px; align-items:center;
    backdrop-filter: blur(6px);
  }
  button {
    appearance:none; border:0; border-radius:14px; padding:10px 14px;
    background:#ffd400; color:#111; font-weight:900; cursor:pointer;
  }
  button:disabled { opacity:.5; cursor:not-allowed; }
  .small { font-size:12px; opacity:.85; }
</style>
</head>

<body>
  <div class="wrap">
    <canvas id="cv" width="1000" height="520"></canvas>
  </div>

  <div class="hud">
    <div class="card">
      <div><b>100mï¼ˆMVPï¼‰</b><div class="small">ã‚¿ãƒƒãƒ—ã§ã‚¹ã‚¿ãƒ¼ãƒˆï¼ˆ1å›å‹è² ï¼‰ã€‚ã‚„ã‚Šç›´ã—ã¯ãƒšãƒ¼ã‚¸æ›´æ–°ã€‚</div></div>
    </div>
    <button id="btnStart">ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
    <div class="card" id="status">å¾…æ©Ÿä¸­</div>
  </div>

<script>
/** =========================
 *  æ”¹è‰¯1ï¼šåå‰å…¥åŠ›ï¼‹ä¿å­˜
 *  - localStorage ã«ä¿å­˜
 *  - ãƒ©ãƒ³ãƒŠãƒ¼è¡¨ç¤ºã«åæ˜ 
 * ========================= */
const STORAGE_KEY = "sprintDynasty_playerName_v1";
function getPlayerName(){
  let name = (localStorage.getItem(STORAGE_KEY) || "").trim();
  if (!name){
    name = prompt("ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆå¾Œã‹ã‚‰å¤‰æ›´ã§ãã¾ã™ï¼‰", "ã‚±ã‚¤ã‚¹ã‚±") || "";
    name = name.trim();
    if (!name) name = "ã‚ãªãŸ";
    localStorage.setItem(STORAGE_KEY, name);
  }
  return name;
}
function setPlayerName(name){
  localStorage.setItem(STORAGE_KEY, String(name || "ã‚ãªãŸ").trim() || "ã‚ãªãŸ");
}

const playerName = getPlayerName();

/** ========= Canvas ========= **/
const canvas = document.getElementById("cv");
const ctx = canvas.getContext("2d");
const W = canvas.width, H = canvas.height;

const btnStart = document.getElementById("btnStart");
const statusEl = document.getElementById("status");

const TRACK = {
  left: 85,
  right: 955,
  top: 92,
  laneH: 48,
  lanes: 8,
  finishX: 920
};

const COLORS = ["#ffd400","#66d9ff","#ff6b6b","#a7ff83","#c792ea","#f78c6c","#89ddff","#f6f7ff"];

let state = "idle"; // idle | running | finished
let t0 = 0;

function rand(min, max) { return min + Math.random()*(max-min); }
function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

function makeStats(base){
  const SPD = clamp(Math.round(base + rand(-4,4)), 20, 99);
  const ACC = clamp(Math.round(base + rand(-4,4)), 20, 99);
  const POW = clamp(Math.round(base + rand(-4,4)), 20, 99);
  const TEC = clamp(Math.round(base + rand(-4,4)), 20, 99);
  const STA = clamp(Math.round(base + rand(-4,4)), 20, 99);
  const MEN = clamp(Math.round(base + rand(-4,4)), 20, 99);
  return {SPD,ACC,POW,TEC,STA,MEN};
}

function buildRunners(){
  const runners = [];

  runners.push({ id:"P001", name:playerName, school:"æ˜¥é¢¨é«˜æ ¡", key:true, portrait:"ğŸ™‚", stats: makeStats(55) });
  runners.push({ id:"R_SAME", name:"é¢¨é–“ è¿…", school:"æ§ãƒ¶å²³é«˜æ ¡", key:true, portrait:"ğŸ˜¼", stats: makeStats(60) });
  runners.push({ id:"BOSS", name:"ä¹æ¡ è’¼çœŸ", school:"å¯Œå£«é«˜æ ¡", key:true, portrait:"ğŸ˜¤", stats: makeStats(62) });

  const mobs = [
    ["ç”°ä¸­ é™¸","åŒ—å²³é«˜æ ¡"],
    ["ä½è—¤ æ‚ çœŸ","å¥¥ç©‚é«˜é«˜æ ¡"],
    ["éˆ´æœ¨ æ¹Š","å¤§é›ªå±±é«˜æ ¡"],
    ["é«˜æ©‹ è“®","ç™½å±±é«˜æ ¡"],
    ["ä¼Šè—¤ éš¼äºº","å¾¡å¶½é«˜æ ¡"],
  ];
  for (const [name,school] of mobs){
    runners.push({ id:"M_"+name, name, school, key:false, portrait:"", stats: makeStats(54) });
  }

  // ãƒ¬ãƒ¼ãƒ³ã‚·ãƒ£ãƒƒãƒ•ãƒ«
  for (let i=runners.length-1;i>0;i--){
    const j=Math.floor(Math.random()*(i+1));
    [runners[i], runners[j]] = [runners[j], runners[i]];
  }

  runners.forEach((r,idx)=>{
    r.lane = idx;
    r.y = TRACK.top + idx*TRACK.laneH;
    r.x = TRACK.left;
    r.v = 0;
    r.done = false;
    r.time = null;

    // ã‚¢ãƒ‹ãƒ¡ç”¨
    r.animPhase = rand(0, Math.PI*2);
  });

  return runners;
}

let runners = buildRunners();

function calcTargetSpeed(stats){
  const base = 2.05;
  const spd = stats.SPD * 0.026;
  const pow = stats.POW * 0.010;
  return base + spd + pow;
}

function updateRunner(r, dt){
  if (r.done) return;

  const {ACC, TEC, STA, MEN} = r.stats;
  const target = calcTargetSpeed(r.stats);

  const accel = (0.65 + ACC*0.010) * dt;

  const jitterAmp = clamp(0.35 - (MEN*0.002 + TEC*0.001), 0.05, 0.35);
  const jitter = (Math.random()*2-1) * jitterAmp;

  const progress = (r.x - TRACK.left) / (TRACK.finishX - TRACK.left);
  const fade = (progress > 0.65) ? ( (0.65-progress) * ( (80-STA)/140 ) ) : 0;
  const fatigueFactor = clamp(1 + fade, 0.88, 1.02);

  r.v += (target - r.v) * accel;
  const step = (r.v + jitter) * fatigueFactor * 60 * dt;
  r.x += Math.max(0.5, step);

  if (r.x >= TRACK.finishX){
    r.x = TRACK.finishX;
    r.done = true;
    r.time = (performance.now() - t0) / 1000;
  }
}

function allDone(){ return runners.every(r=>r.done); }

function roundRect(x, y, w, h, r, fill, stroke) {
  if (w < 2*r) r = w/2;
  if (h < 2*r) r = h/2;
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y,   x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x,   y+h, r);
  ctx.arcTo(x,   y+h, x,   y,   r);
  ctx.arcTo(x,   y,   x+w, y,   r);
  ctx.closePath();
  if (fill) ctx.fill();
  if (stroke) ctx.stroke();
}

function drawStadiumBg(){
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0, "#0a1c35");
  g.addColorStop(1, "#081326");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);

  ctx.fillStyle = "rgba(255,255,255,.06)";
  ctx.beginPath(); ctx.arc(160, 80, 120, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(840, 70, 140, 0, Math.PI*2); ctx.fill();
}

function drawTrack(){
  drawStadiumBg();

  const pad = 24;
  const trackX = pad, trackY = pad, trackW = W-pad*2, trackH = H-pad*2;
  ctx.fillStyle = "#1d4f9a";
  roundRect(trackX, trackY, trackW, trackH, 18, true, false);

  // è³ªæ„Ÿ
  ctx.save();
  ctx.globalAlpha = 0.08;
  ctx.strokeStyle = "#ffffff";
  ctx.lineWidth = 2;
  for(let x = -H; x < W+H; x += 22){
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x+H, H);
    ctx.stroke();
  }
  ctx.restore();

  // å†…å´
  ctx.fillStyle = "rgba(0,0,0,.18)";
  roundRect(TRACK.left-28, TRACK.top-28, (TRACK.finishX-(TRACK.left-28))+60, TRACK.lanes*TRACK.laneH+56, 16, true, false);

  // ãƒ¬ãƒ¼ãƒ³
  ctx.strokeStyle = "rgba(255,255,255,.42)";
  ctx.lineWidth = 2;
  for (let i=0;i<=TRACK.lanes;i++){
    const y = TRACK.top + i*TRACK.laneH;
    ctx.beginPath();
    ctx.moveTo(TRACK.left, y);
    ctx.lineTo(TRACK.right, y);
    ctx.stroke();
  }

  // ãƒ¬ãƒ¼ãƒ³ç•ªå·
  ctx.fillStyle = "rgba(255,255,255,.75)";
  ctx.font = "700 12px system-ui";
  for(let i=0;i<TRACK.lanes;i++){
    ctx.fillText(String(i+1), TRACK.left-22, TRACK.top + i*TRACK.laneH + 30);
  }

  // ã‚¹ã‚¿ãƒ¼ãƒˆ
  ctx.strokeStyle = "rgba(255,255,255,.92)";
  ctx.lineWidth = 5;
  ctx.beginPath();
  ctx.moveTo(TRACK.left, TRACK.top);
  ctx.lineTo(TRACK.left, TRACK.top + TRACK.lanes*TRACK.laneH);
  ctx.stroke();

  // ã‚´ãƒ¼ãƒ«ï¼ˆå¸‚æ¾ï¼‰
  const fy0 = TRACK.top, fy1 = TRACK.top + TRACK.lanes*TRACK.laneH;
  const block = 10;
  for(let y=fy0; y<fy1; y+=block){
    const on = ((Math.floor((y-fy0)/block)) % 2) === 0;
    ctx.fillStyle = on ? "rgba(255,255,255,.95)" : "rgba(0,0,0,.55)";
    ctx.fillRect(TRACK.finishX, y, 10, block);
  }

  // 100m
  ctx.fillStyle = "rgba(255,255,255,.9)";
  ctx.font = "900 18px system-ui";
  ctx.fillText("100m", TRACK.left, 46);
}

/** =========================
 *  èµ°ã‚‹ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³å¼·åŒ–ï¼ˆCanvasæç”»ï¼‰
 *  - ä¸Šä¸‹ãƒã‚¦ãƒ³ã‚¹
 *  - å‰å‚¾
 *  - è…•æŒ¯ã‚Šå¼·ã‚
 *  - è¶³ã®è¸ã¿æ›¿ãˆï¼ˆæ¥åœ°æ„Ÿï¼‰
 * ========================= */
function drawRunnerHuman(r, now){
  const laneColor = COLORS[r.lane % COLORS.length];

  const running = (state === "running") && !r.done;

  // runner speed factor for animation feel
  const speed01 = clamp(r.v / 4.0, 0.2, 1.0);

  // phase: move faster with speed
  const phase = running ? (now/80 * (0.8 + speed01*1.2) + r.animPhase) : r.animPhase;

  // bounce & lean
  const bounce = running ? Math.sin(phase) * (2.2 + speed01*1.4) : 0;
  const lean = running ? (0.18 + speed01*0.10) : 0.10; // radians

  // limb swings
  const swing = running ? Math.sin(phase) : 0;
  const swing2 = running ? Math.sin(phase + Math.PI/2) : 0;

  // base body position (center)
  const cx = r.x + 12;
  const cy = r.y + 28 + bounce;

  // shadow (changes with bounce)
  ctx.fillStyle = "rgba(0,0,0,.28)";
  ctx.beginPath();
  ctx.ellipse(cx+4, cy+26, 12 - bounce*0.25, 4 - bounce*0.08, 0, 0, Math.PI*2);
  ctx.fill();

  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(-lean);

  // Legs (two, alternating; one forward, one back)
  ctx.strokeStyle = "rgba(0,0,0,.55)";
  ctx.lineWidth = 3.2;
  ctx.lineCap = "round";

  const legSpread = 10 + speed01*6;
  const kneeLift = 5 + speed01*4;

  // front leg
  const lf = swing * legSpread;
  ctx.beginPath();
  ctx.moveTo(-2, 12);
  ctx.lineTo(-4 + lf*0.18, 22);
  // foot contact
  ctx.lineTo(-6 + lf*0.22, 24 + Math.max(0, -swing)*2);
  ctx.stroke();

  // back leg
  const lb = -swing * legSpread;
  ctx.beginPath();
  ctx.moveTo( 2, 12);
  ctx.lineTo( 4 + lb*0.18, 22);
  ctx.lineTo( 6 + lb*0.22, 24 + Math.max(0, swing)*2);
  ctx.stroke();

  // Torso (uniform)
  ctx.fillStyle = laneColor;
  roundRect(-9, -4, 18, 20, 5, true, false);

  // bib
  ctx.fillStyle = "rgba(255,255,255,.88)";
  roundRect(-7, 5, 14, 9, 2, true, false);
  ctx.fillStyle = "rgba(0,0,0,.65)";
  ctx.font = "700 9px system-ui";
  ctx.fillText(String(r.lane+1), -2.5, 12);

  // Arms (stronger swing)
  ctx.strokeStyle = "rgba(0,0,0,.55)";
  ctx.lineWidth = 3.0;

  const armSpread = 14 + speed01*8;
  const a1 = swing2 * armSpread;     // opposite timing
  const a2 = -swing2 * armSpread;

  // left arm
  ctx.beginPath();
  ctx.moveTo(-8, 0);
  ctx.lineTo(-14 + a1*0.20, 6 + (-swing2)*2);
  ctx.stroke();

  // right arm
  ctx.beginPath();
  ctx.moveTo( 8, 0);
  ctx.lineTo( 14 + a2*0.20, 6 + (swing2)*2);
  ctx.stroke();

  // Head
  ctx.fillStyle = "rgba(255,255,255,.95)";
  ctx.beginPath();
  ctx.arc(0, -12 - (running ? Math.max(0, swing)*0.8 : 0), 6.2, 0, Math.PI*2);
  ctx.fill();
  ctx.strokeStyle = "rgba(0,0,0,.25)";
  ctx.lineWidth = 1.4;
  ctx.stroke();

  ctx.restore();

  // label (right side)
  const labelX = TRACK.finishX + 14;
  const labelY = r.y + 25;

  ctx.fillStyle = "rgba(0,0,0,.55)";
  roundRect(labelX-6, labelY-14, 240, 22, 8, true, false);

  ctx.fillStyle = "#fff";
  ctx.font = "12px system-ui";
  ctx.fillText(`${r.name}ï¼ˆ${r.school}ï¼‰`, labelX, labelY);

  // portrait bubble for key characters (emoji for now)
  if (r.key){
    const bx = r.x + 40;
    const by = r.y - 10;
    ctx.fillStyle = "rgba(255,255,255,.92)";
    roundRect(bx, by, 44, 30, 8, true, false);
    ctx.beginPath();
    ctx.moveTo(bx+10, by+30);
    ctx.lineTo(bx+18, by+30);
    ctx.lineTo(bx+12, by+38);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = "#111";
    ctx.font = "20px system-ui";
    ctx.fillText(r.portrait || "ğŸ™‚", bx+10, by+22);
  }
}

function draw(now){
  drawTrack();
  runners.forEach(r => drawRunnerHuman(r, now));

  if (state === "finished"){
    const sorted = [...runners].sort((a,b)=>a.time - b.time);

    ctx.fillStyle = "rgba(0,0,0,.70)";
    roundRect(630, 30, 340, 190, 16, true, false);

    ctx.fillStyle = "#eaf2ff";
    ctx.font = "900 16px system-ui";
    ctx.fillText("çµæœï¼ˆæ±ºå‹ï¼‰", 650, 60);

    ctx.font = "13px system-ui";
    sorted.slice(0,8).forEach((r,i)=>{
      ctx.fillText(`${i+1}ä½  ${r.name}  ${r.time.toFixed(2)}s`, 650, 88 + i*18);
    });

    const win = sorted[0];
    statusEl.textContent = `å¤§ä¼šçµ‚äº†ï¼šå„ªå‹ ${win.name}ï¼ˆ${win.time.toFixed(2)}sï¼‰`;
  }
}

let last = performance.now();
function loop(now){
  const dt = (now - last) / 1000;
  last = now;

  if (state === "running"){
    runners.forEach(r => updateRunner(r, dt));
    if (allDone()){
      state = "finished";
      btnStart.disabled = true; // ä¸€ç™ºå‹è² 
    }
  }

  draw(now);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

function startRace(){
  if (state !== "idle") return;
  state = "running";
  t0 = performance.now();
  btnStart.disabled = true;
  statusEl.textContent = "ãƒ¬ãƒ¼ã‚¹ä¸­â€¦";
}

btnStart.addEventListener("click", startRace);
canvas.addEventListener("click", ()=>{ if (state === "idle") startRace(); });

/** è¿½åŠ ï¼šåå‰ã‚’å¤‰ãˆãŸã„æ™‚ã®è£ã‚³ãƒãƒ³ãƒ‰ï¼ˆé–‹ç™ºç”¨ï¼‰
 *  ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ãŒã‚ã‚‹ç’°å¢ƒãªã‚‰ N ã§å¤‰æ›´ã§ãã‚‹
 */
window.addEventListener("keydown", (e)=>{
  if (e.key.toLowerCase() === "n"){
    const next = (prompt("ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åã‚’å¤‰æ›´ã—ã¾ã™", localStorage.getItem(STORAGE_KEY) || playerName) || "").trim();
    if (next){
      setPlayerName(next);
      location.reload();
    }
  }
});
</script>
</body>
</html>
